<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8"/>
    <title>An Introduction to FsPickler
</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <meta name="description" content="A general-purpose serialization library for .NET"/>
    <meta name="author" content="Eirik Tsarpalis"/>

    <script src="https://code.jquery.com/jquery-1.8.0.js"></script>
    <script src="https://code.jquery.com/ui/1.8.23/jquery-ui.js"></script>
    <script src="https://netdna.bootstrapcdn.com/twitter-bootstrap/2.2.1/js/bootstrap.min.js"></script>
    <link href="https://netdna.bootstrapcdn.com/twitter-bootstrap/2.2.1/css/bootstrap-combined.min.css" rel="stylesheet"/>

    <link type="text/css" rel="stylesheet" href="/FsPickler/content/style.css" />
    <script type="text/javascript" src="/FsPickler/content/tips.js"></script>
    <!-- HTML5 shim, for IE6-8 support of HTML5 elements -->
    <!--[if lt IE 9]>
      <script src="https://html5shim.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
  </head>
  <body>
    <div class="container">
      <div class="masthead">
        <ul class="nav nav-pills pull-right">
          <li><a href="http://mbrace.io/">mbrace</a></li>
          <li><a href="http://github.com/mbraceproject/FsPickler">github page</a></li>
        </ul>
        <h3 class="muted"><a href="/FsPickler/index.html">FsPickler</a></h3>
      </div>
      <hr />
      <div class="row">
        <div class="span9" id="main">
          
<h1><a name="An-Introduction-to-FsPickler" class="anchor" href="#An-Introduction-to-FsPickler">An Introduction to FsPickler</a></h1>
<p>The following provides an overview of the basic functionalities offered by the library.</p>
<h2><a name="The-core-serialization-API" class="anchor" href="#The-core-serialization-API">The core serialization API</a></h2>
<p>The basic API is accessible through instances of type <a href="reference/mbrace-fspickler-fspicklerserializer.html"><code>FsPicklerSerializer</code></a>
that can be initialized as follows:</p>
<table class="pre"><tr><td class="lines"><pre class="fssnip"><span class="l">1: </span>
<span class="l">2: </span>
<span class="l">3: </span>
<span class="l">4: </span>
<span class="l">5: </span>
<span class="l">6: </span>
</pre></td>
<td class="snippet"><pre class="fssnip highlighted"><code lang="fsharp"><span class="prep">#r</span> <span class="s">&quot;FsPickler.dll&quot;</span>

<span class="k">open</span> <span class="i">MBrace</span><span class="o">.</span><span class="i">FsPickler</span>

<span class="k">let</span> <span class="i">binarySerializer</span> <span class="o">=</span> <span class="i">FsPickler</span><span class="o">.</span><span class="i">CreateBinarySerializer</span>()
<span class="k">let</span> <span class="i">xmlSerializer</span> <span class="o">=</span> <span class="i">FsPickler</span><span class="o">.</span><span class="i">CreateXmlSerializer</span>(<span class="i">indent</span> <span class="o">=</span> <span class="k">true</span>)
</code></pre></td>
</tr>
</table>
<p>Json serialization formats can be accessed by referencing the <code>FsPickler.Json</code> project.
If evaluating from F# interactive, make sure to <a href="https://github.com/mbraceproject/FsPickler/issues/16">add an explicit reference to Json.Net</a>.</p>
<table class="pre"><tr><td class="lines"><pre class="fssnip"><span class="l">1: </span>
<span class="l">2: </span>
<span class="l">3: </span>
<span class="l">4: </span>
<span class="l">5: </span>
<span class="l">6: </span>
<span class="l">7: </span>
</pre></td>
<td class="snippet"><pre class="fssnip highlighted"><code lang="fsharp"><span class="prep">#r</span> <span class="s">&quot;Newtonsoft.Json.dll&quot;</span>
<span class="prep">#r</span> <span class="s">&quot;FsPickler.Json.dll&quot;</span>

<span class="k">open</span> <span class="i">MBrace</span><span class="o">.</span><span class="i">FsPickler</span><span class="o">.</span><span class="i">Json</span>

<span class="k">let</span> <span class="i">jsonSerializer</span> <span class="o">=</span> <span class="i">FsPickler</span><span class="o">.</span><span class="i">CreateJsonSerializer</span>(<span class="i">indent</span> <span class="o">=</span> <span class="k">false</span>)
<span class="k">let</span> <span class="i">bsonSerializer</span> <span class="o">=</span> <span class="i">FsPickler</span><span class="o">.</span><span class="i">CreateBsonSerializer</span>()
</code></pre></td>
</tr>
</table>
<p>A simple serialization/deserialization roundtrip can be performed as follows:</p>
<table class="pre"><tr><td class="lines"><pre class="fssnip"><span class="l">1: </span>
<span class="l">2: </span>
</pre></td>
<td class="snippet"><pre class="fssnip highlighted"><code lang="fsharp"><span class="i">xmlSerializer</span><span class="o">.</span><span class="i">Serialize</span>(<span class="i">stream</span>, [<span class="n">0.</span> <span class="o">..</span> <span class="n">0.1</span> <span class="o">..</span> <span class="n">1.</span>])
<span class="i">xmlSerializer</span><span class="o">.</span><span class="i">Deserialize</span><span class="o">&lt;</span><span class="i">float</span> <span class="i">list</span><span class="o">&gt;</span>(<span class="i">stream</span>)
</code></pre></td>
</tr>
</table>
<p>FsPickler instances can be used to produce binary pickles,
that is byte arrays containing the serialized values:</p>
<table class="pre"><tr><td class="lines"><pre class="fssnip"><span class="l">1: </span>
<span class="l">2: </span>
</pre></td>
<td class="snippet"><pre class="fssnip highlighted"><code lang="fsharp"><span class="k">let</span> <span class="i">pickle</span> <span class="o">=</span> <span class="i">binarySerializer</span><span class="o">.</span><span class="i">Pickle</span> &lt;@ <span class="n">1</span> <span class="o">+</span> <span class="n">1</span> @&gt;
<span class="i">binarySerializer</span><span class="o">.</span><span class="i">UnPickle</span><span class="o">&lt;</span><span class="i">Quotations</span><span class="o">.</span><span class="i">Expr</span><span class="o">&lt;</span><span class="i">int</span><span class="o">&gt;</span><span class="o">&gt;</span> <span class="i">pickle</span>
</code></pre></td>
</tr>
</table>
<h3><a name="Text-based-serialization" class="anchor" href="#Text-based-serialization">Text-based serialization</a></h3>
<p>The Xml and Json serializers are instances of type <a href="reference/mbrace-fspickler-fspicklertextserializer.html"><code>FsPicklerTextSerializer</code></a>
that offers functionality for text-based serialization:</p>
<table class="pre"><tr><td class="lines"><pre class="fssnip"><span class="l">1: </span>
<span class="l">2: </span>
<span class="l">3: </span>
<span class="l">4: </span>
<span class="l">5: </span>
</pre></td>
<td class="snippet"><pre class="fssnip highlighted"><code lang="fsharp"><span class="i">xmlSerializer</span><span class="o">.</span><span class="i">Serialize</span>(<span class="i">textWriter</span>, [ <span class="i">Some</span> <span class="n">1</span> ; <span class="i">Some</span> <span class="n">2</span> ; <span class="i">None</span> ])
<span class="i">xmlSerializer</span><span class="o">.</span><span class="i">Deserialize</span><span class="o">&lt;</span><span class="i">int</span> <span class="i">option</span> <span class="i">list</span><span class="o">&gt;</span>(<span class="i">textReader</span>)

<span class="k">let</span> <span class="i">text</span> <span class="o">=</span> <span class="i">jsonSerializer</span><span class="o">.</span><span class="i">PickleToString</span> (<span class="k">fun</span> <span class="i">x</span> <span class="k">-&gt;</span> <span class="i">x</span> <span class="o">+</span> <span class="n">1</span>)
<span class="i">jsonSerializer</span><span class="o">.</span><span class="i">UnPickleOfString</span><span class="o">&lt;</span><span class="i">int</span> <span class="k">-&gt;</span> <span class="i">int</span><span class="o">&gt;</span> <span class="i">text</span>
</code></pre></td>
</tr>
</table>
<h3><a name="Sequence-serialization" class="anchor" href="#Sequence-serialization">Sequence serialization</a></h3>
<p>FsPickler offers support for on-demand sequence serialization/deserialization:</p>
<table class="pre"><tr><td class="lines"><pre class="fssnip"><span class="l">1: </span>
<span class="l">2: </span>
<span class="l">3: </span>
<span class="l">4: </span>
<span class="l">5: </span>
</pre></td>
<td class="snippet"><pre class="fssnip highlighted"><code lang="fsharp"><span class="k">let</span> <span class="i">seq</span> <span class="o">=</span> <span class="i">Seq</span><span class="o">.</span><span class="i">initInfinite</span> <span class="i">string</span> <span class="o">|&gt;</span> <span class="i">Seq</span><span class="o">.</span><span class="i">take</span> <span class="n">100</span>

<span class="k">let</span> <span class="i">length</span> <span class="o">=</span> <span class="i">binarySerializer</span><span class="o">.</span><span class="i">SerializeSequence</span>(<span class="i">stream</span>, <span class="i">seq</span>) <span class="c">// returns the length of serialized elements</span>
<span class="k">let</span> <span class="i">seq&#39;</span> <span class="o">=</span> <span class="i">binarySerializer</span><span class="o">.</span><span class="i">DeserializeSequence</span><span class="o">&lt;</span><span class="i">int</span><span class="o">&gt;</span>(<span class="i">stream</span>) <span class="c">// lazy deserialization IEnumerable</span>
<span class="i">Seq</span><span class="o">.</span><span class="i">toArray</span> <span class="i">seq&#39;</span> <span class="c">// evaluation forces full deserialization</span>
</code></pre></td>
</tr>
</table>
<h2><a name="Picklers-and-Pickler-combinators" class="anchor" href="#Picklers-and-Pickler-combinators">Picklers and Pickler combinators</a></h2>
<p>A pickler is essentially the type</p>
<table class="pre"><tr><td class="lines"><pre class="fssnip"><span class="l">1: </span>
<span class="l">2: </span>
<span class="l">3: </span>
<span class="l">4: </span>
<span class="l">5: </span>
</pre></td>
<td class="snippet"><pre class="fssnip highlighted"><code lang="fsharp"><span class="k">type</span> <span class="i">Pickler</span><span class="o">&lt;</span><span class="o">&#39;</span><span class="i">T</span><span class="o">&gt;</span> <span class="o">=</span>
    {
        <span class="i">Write</span> <span class="o">:</span> <span class="i">WriteState</span> <span class="k">-&gt;</span> <span class="o">&#39;</span><span class="i">T</span> <span class="k">-&gt;</span> <span class="i">unit</span>
        <span class="i">Read</span>  <span class="o">:</span> <span class="i">ReadState</span>  <span class="k">-&gt;</span> <span class="o">&#39;</span><span class="i">T</span>
    }
</code></pre></td>
</tr>
</table>
<p>which defines the serialization/deserialization rules for a given type.
Picklers are strongly typed and perform serialization without reflection
or intermediate boxings.</p>
<p>There are two kinds of picklers:</p>
<ul>
<li>
<p>Primitive or atomic picklers that are self-contained definitions
for simple values like primitives, strings or timespans.</p>
</li>
<li>
<p>Composite picklers which are derived from composition of simpler types.
They are generated using <em>pickler combinators</em>, functions taking a collection
of picklers as inputs yielding a composite result.</p>
</li>
</ul>
<p>FsPickler is essentially an automated pickler generation framework: picklers are generated at runtime
and on demand using a combination of reflection and dynamic IL generation. Picklers are cached for
future use, hence the cost of generation has a constant price.</p>
<p>Moreover, the library provides an experimental combinator module that allows direct manipulation
of picklers in a more functional style:</p>
<table class="pre"><tr><td class="lines"><pre class="fssnip"><span class="l"> 1: </span>
<span class="l"> 2: </span>
<span class="l"> 3: </span>
<span class="l"> 4: </span>
<span class="l"> 5: </span>
<span class="l"> 6: </span>
<span class="l"> 7: </span>
<span class="l"> 8: </span>
<span class="l"> 9: </span>
<span class="l">10: </span>
<span class="l">11: </span>
<span class="l">12: </span>
<span class="l">13: </span>
<span class="l">14: </span>
<span class="l">15: </span>
<span class="l">16: </span>
<span class="l">17: </span>
<span class="l">18: </span>
<span class="l">19: </span>
</pre></td>
<td class="snippet"><pre class="fssnip highlighted"><code lang="fsharp"><span class="k">open</span> <span class="i">MBrace</span><span class="o">.</span><span class="i">FsPickler</span><span class="o">.</span><span class="i">Combinators</span>

<span class="c">// atomic picklers</span>
<span class="k">let</span> <span class="i">int</span> <span class="o">=</span> <span class="i">Pickler</span><span class="o">.</span><span class="i">int</span>
<span class="k">let</span> <span class="i">string</span> <span class="o">=</span> <span class="i">Pickler</span><span class="o">.</span><span class="i">string</span>
<span class="k">let</span> <span class="i">dateTime</span> <span class="o">=</span> <span class="i">Pickler</span><span class="o">.</span><span class="i">dateTime</span>

<span class="c">// composite picklers</span>
<span class="k">let</span> <span class="i">p1</span> <span class="o">=</span> <span class="i">Pickler</span><span class="o">.</span><span class="i">pair</span> <span class="i">int</span> <span class="i">dateTime</span>
<span class="k">let</span> <span class="i">p2</span> <span class="o">=</span> <span class="i">Pickler</span><span class="o">.</span><span class="i">option</span> <span class="i">string</span>
<span class="k">let</span> <span class="i">p3</span> <span class="o">=</span> <span class="i">Pickler</span><span class="o">.</span><span class="i">list</span> <span class="i">p2</span>
<span class="k">let</span> <span class="i">p4</span> <span class="o">=</span> <span class="i">Pickler</span><span class="o">.</span><span class="i">array2D</span> <span class="i">p1</span>
<span class="k">let</span> <span class="i">p5</span> <span class="o">=</span> <span class="i">Pickler</span><span class="o">.</span><span class="i">auto</span><span class="o">&lt;</span><span class="i">int</span> <span class="o">*</span> <span class="i">string</span> <span class="i">option</span> <span class="i">list</span><span class="o">&gt;</span>

<span class="c">// pickler-based serialization</span>
<span class="k">let</span> <span class="i">t1</span> <span class="o">=</span> <span class="i">Binary</span><span class="o">.</span><span class="i">pickle</span> <span class="i">int</span> <span class="n">42</span>
<span class="k">let</span> <span class="i">t2</span> <span class="o">=</span> <span class="i">Json</span><span class="o">.</span><span class="i">pickle</span> <span class="i">p3</span> [ <span class="i">Some</span> <span class="s">&quot;&quot;</span> ; <span class="i">None</span> ; <span class="i">Some</span> <span class="s">&quot;message&quot;</span> ]

<span class="i">Json</span><span class="o">.</span><span class="i">unpickle</span> <span class="i">p3</span> <span class="i">t2</span>
</code></pre></td>
</tr>
</table>
<p>The module includes all primitive combinators as described in Andrew Kennedy's
<a href="http://research.microsoft.com/en-us/um/people/akenn/fun/picklercombinators.pdf">Pickler Combinators</a>
like<code>wrap</code> and <code>alt</code>. Fixpoint combinators for declaring recursive picklers are also available:</p>
<table class="pre"><tr><td class="lines"><pre class="fssnip"><span class="l"> 1: </span>
<span class="l"> 2: </span>
<span class="l"> 3: </span>
<span class="l"> 4: </span>
<span class="l"> 5: </span>
<span class="l"> 6: </span>
<span class="l"> 7: </span>
<span class="l"> 8: </span>
<span class="l"> 9: </span>
<span class="l">10: </span>
</pre></td>
<td class="snippet"><pre class="fssnip highlighted"><code lang="fsharp"><span class="k">type</span> <span class="i">Peano</span> <span class="o">=</span> <span class="i">Zero</span> | <span class="i">Succ</span> <span class="k">of</span> <span class="i">Peano</span>

<span class="k">let</span> <span class="i">pp</span> <span class="o">:</span> <span class="i">Pickler</span><span class="o">&lt;</span><span class="i">Peano</span><span class="o">&gt;</span> <span class="o">=</span>
    <span class="i">Pickler</span><span class="o">.</span><span class="i">fix</span>(<span class="k">fun</span> <span class="i">peano</span> <span class="k">-&gt;</span>
        <span class="i">peano</span>
        <span class="o">|&gt;</span> <span class="i">Pickler</span><span class="o">.</span><span class="i">option</span>
        <span class="o">|&gt;</span> <span class="i">Pickler</span><span class="o">.</span><span class="i">wrap</span> (<span class="k">function</span> <span class="i">None</span> <span class="k">-&gt;</span> <span class="i">Zero</span> | <span class="i">Some</span> <span class="i">p</span> <span class="k">-&gt;</span> <span class="i">Succ</span> <span class="i">p</span>)
                        (<span class="k">function</span> <span class="i">Zero</span> <span class="k">-&gt;</span> <span class="i">None</span> | <span class="i">Succ</span> <span class="i">p</span> <span class="k">-&gt;</span> <span class="i">Some</span> <span class="i">p</span>))
                        
<span class="i">Succ</span> (<span class="i">Succ</span> <span class="i">Zero</span>) <span class="o">|&gt;</span> <span class="i">Binary</span><span class="o">.</span><span class="i">pickle</span> <span class="i">pp</span> <span class="o">|&gt;</span> <span class="i">Binary</span><span class="o">.</span><span class="i">unpickle</span> <span class="i">pp</span>
</code></pre></td>
</tr>
</table>
<p>When it comes to generic types, picklers can be created through user-defined combinators:</p>
<table class="pre"><tr><td class="lines"><pre class="fssnip"><span class="l"> 1: </span>
<span class="l"> 2: </span>
<span class="l"> 3: </span>
<span class="l"> 4: </span>
<span class="l"> 5: </span>
<span class="l"> 6: </span>
<span class="l"> 7: </span>
<span class="l"> 8: </span>
<span class="l"> 9: </span>
<span class="l">10: </span>
<span class="l">11: </span>
<span class="l">12: </span>
</pre></td>
<td class="snippet"><pre class="fssnip highlighted"><code lang="fsharp"><span class="k">type</span> <span class="i">Tree</span><span class="o">&lt;</span><span class="o">&#39;</span><span class="i">T</span><span class="o">&gt;</span> <span class="o">=</span> <span class="i">Leaf</span> | <span class="i">Node</span> <span class="k">of</span> <span class="o">&#39;</span><span class="i">T</span> <span class="o">*</span> <span class="i">Tree</span><span class="o">&lt;</span><span class="o">&#39;</span><span class="i">T</span><span class="o">&gt;</span> <span class="i">list</span>

<span class="k">let</span> <span class="i">mkTree</span> (<span class="i">ep</span> <span class="o">:</span> <span class="i">Pickler</span><span class="o">&lt;</span><span class="o">&#39;</span><span class="i">T</span><span class="o">&gt;</span>) <span class="o">=</span>
    <span class="i">Pickler</span><span class="o">.</span><span class="i">fix</span>(<span class="k">fun</span> <span class="i">tree</span> <span class="k">-&gt;</span>
        <span class="i">tree</span>
        <span class="o">|&gt;</span> <span class="i">Pickler</span><span class="o">.</span><span class="i">list</span>
        <span class="o">|&gt;</span> <span class="i">Pickler</span><span class="o">.</span><span class="i">pair</span> <span class="i">ep</span>
        <span class="o">|&gt;</span> <span class="i">Pickler</span><span class="o">.</span><span class="i">option</span>
        <span class="o">|&gt;</span> <span class="i">Pickler</span><span class="o">.</span><span class="i">wrap</span> (<span class="k">function</span> <span class="i">None</span> <span class="k">-&gt;</span> <span class="i">Leaf</span> | <span class="i">Some</span> (<span class="i">t</span>,<span class="i">c</span>) <span class="k">-&gt;</span> <span class="i">Node</span>(<span class="i">t</span>,<span class="i">c</span>))
                        (<span class="k">function</span> <span class="i">Leaf</span> <span class="k">-&gt;</span> <span class="i">None</span> | <span class="i">Node</span> (<span class="i">t</span>,<span class="i">c</span>) <span class="k">-&gt;</span> <span class="i">Some</span>(<span class="i">t</span>,<span class="i">c</span>)))
                        
<span class="i">Node</span>(<span class="n">2</span>,[]) <span class="o">|&gt;</span> <span class="i">Xml</span><span class="o">.</span><span class="i">pickle</span> (<span class="i">mkTree</span> <span class="i">Pickler</span><span class="o">.</span><span class="i">int</span>)
</code></pre></td>
</tr>
</table>
<p>or it could be done using automatic resolution of type parameters:</p>
<table class="pre"><tr><td class="lines"><pre class="fssnip"><span class="l"> 1: </span>
<span class="l"> 2: </span>
<span class="l"> 3: </span>
<span class="l"> 4: </span>
<span class="l"> 5: </span>
<span class="l"> 6: </span>
<span class="l"> 7: </span>
<span class="l"> 8: </span>
<span class="l"> 9: </span>
<span class="l">10: </span>
<span class="l">11: </span>
</pre></td>
<td class="snippet"><pre class="fssnip highlighted"><code lang="fsharp"><span class="k">let</span> <span class="i">tree</span><span class="o">&lt;</span><span class="o">&#39;</span><span class="i">T</span><span class="o">&gt;</span> <span class="o">=</span>
    <span class="i">Pickler</span><span class="o">.</span><span class="i">fix</span>(<span class="k">fun</span> <span class="i">tree</span> <span class="k">-&gt;</span>
        <span class="i">tree</span>
        <span class="o">|&gt;</span> <span class="i">Pickler</span><span class="o">.</span><span class="i">list</span>
        <span class="o">|&gt;</span> <span class="i">Pickler</span><span class="o">.</span><span class="i">pair</span> <span class="i">Pickler</span><span class="o">.</span><span class="i">auto</span><span class="o">&lt;</span><span class="o">&#39;</span><span class="i">T</span><span class="o">&gt;</span>
        <span class="o">|&gt;</span> <span class="i">Pickler</span><span class="o">.</span><span class="i">option</span>
        <span class="o">|&gt;</span> <span class="i">Pickler</span><span class="o">.</span><span class="i">wrap</span> (<span class="k">function</span> <span class="i">None</span> <span class="k">-&gt;</span> <span class="i">Leaf</span> | <span class="i">Some</span> (<span class="i">t</span>,<span class="i">c</span>) <span class="k">-&gt;</span> <span class="i">Node</span>(<span class="i">t</span>,<span class="i">c</span>))
                        (<span class="k">function</span> <span class="i">Leaf</span> <span class="k">-&gt;</span> <span class="i">None</span> | <span class="i">Node</span> (<span class="i">t</span>,<span class="i">c</span>) <span class="k">-&gt;</span> <span class="i">Some</span>(<span class="i">t</span>,<span class="i">c</span>)))


<span class="i">Node</span>([<span class="n">1</span>],[<span class="i">Leaf</span> ; <span class="i">Leaf</span>]) <span class="o">|&gt;</span> <span class="i">Json</span><span class="o">.</span><span class="i">pickle</span> <span class="i">tree</span>
</code></pre></td>
</tr>
</table>
<h3><a name="SerializationInfo-Picklers" class="anchor" href="#SerializationInfo-Picklers">SerializationInfo Picklers</a></h3>
<p>It is possible to define picklers that serialise objects using <a href="https://msdn.microsoft.com/en-us/library/system.runtime.serialization.serializationinfo%28v=vs.110%29.aspx">SerializationInfo</a>.
For example, consider the record:</p>
<table class="pre"><tr><td class="lines"><pre class="fssnip"><span class="l">1: </span>
</pre></td>
<td class="snippet"><pre class="fssnip highlighted"><code lang="fsharp"><span class="k">type</span> <span class="i">Name</span> <span class="o">=</span> { <span class="i">FirstName</span> <span class="o">:</span> <span class="i">string</span> ; <span class="i">MiddleName</span> <span class="o">:</span> <span class="i">string</span> <span class="i">option</span> ; <span class="i">Surname</span> <span class="o">:</span> <span class="i">string</span> }
</code></pre></td>
</tr>
</table>
<p>We can define a SerializationInfo based pickler using the following combinator:</p>
<table class="pre"><tr><td class="lines"><pre class="fssnip"><span class="l"> 1: </span>
<span class="l"> 2: </span>
<span class="l"> 3: </span>
<span class="l"> 4: </span>
<span class="l"> 5: </span>
<span class="l"> 6: </span>
<span class="l"> 7: </span>
<span class="l"> 8: </span>
<span class="l"> 9: </span>
<span class="l">10: </span>
</pre></td>
<td class="snippet"><pre class="fssnip highlighted"><code lang="fsharp"><span class="k">let</span> <span class="i">nameP</span> <span class="o">=</span>
    <span class="i">Pickler</span><span class="o">.</span><span class="i">fromSerializationInfo</span>
                (<span class="k">fun</span> <span class="i">si</span> <span class="k">-&gt;</span> 
                    { <span class="i">FirstName</span> <span class="o">=</span> <span class="i">si</span><span class="o">.</span><span class="i">Get</span> <span class="s">&quot;First Name&quot;</span>
                      <span class="i">MiddleName</span> <span class="o">=</span> <span class="i">si</span><span class="o">.</span><span class="i">TryGet</span> <span class="s">&quot;Middle Name&quot;</span>
                      <span class="i">Surname</span> <span class="o">=</span> <span class="i">si</span><span class="o">.</span><span class="i">Get</span> <span class="s">&quot;Last Name&quot;</span> })
                (<span class="k">fun</span> <span class="i">si</span> <span class="i">p</span> <span class="k">-&gt;</span> 
                    <span class="i">si</span><span class="o">.</span><span class="i">Add</span>(<span class="s">&quot;First Name&quot;</span>, <span class="i">p</span><span class="o">.</span><span class="i">FirstName</span>)
                    <span class="i">si</span><span class="o">.</span><span class="i">Add</span>(<span class="s">&quot;Last Name&quot;</span>, <span class="i">p</span><span class="o">.</span><span class="i">Surname</span>)
                    <span class="k">match</span> <span class="i">p</span><span class="o">.</span><span class="i">MiddleName</span> <span class="k">with</span> <span class="i">Some</span> <span class="i">mn</span> <span class="k">-&gt;</span> <span class="i">si</span><span class="o">.</span><span class="i">Add</span>(<span class="s">&quot;Middle Name&quot;</span>, <span class="i">mn</span>) | <span class="i">None</span> <span class="k">-&gt;</span> ())
</code></pre></td>
</tr>
</table>
<h3><a name="Experimental-N-way-Sum-and-Product-Combinators" class="anchor" href="#Experimental-N-way-Sum-and-Product-Combinators">Experimental N-way Sum and Product Combinators</a></h3>
<p>N-way sum and product combinators provide an alternative pretty syntax for
defining picklers over arbitrary discriminated unions and records.  Unfortunately
at the moment the performance of resulting picklers is sub-optimal, this might
improve in the future.</p>
<p>The types involved in the examples are not fit for human consumption, but thankfully
F# infers them automatically. The implementation is total and purely functional,
see this <a href="https://gist.github.com/t0yv0/6834822">gist</a> for some Coq code used to model these combinators.</p>
<h4><a name="Records-Product-Types" class="anchor" href="#Records-Product-Types">Records / Product Types</a></h4>
<table class="pre"><tr><td class="lines"><pre class="fssnip"><span class="l"> 1: </span>
<span class="l"> 2: </span>
<span class="l"> 3: </span>
<span class="l"> 4: </span>
<span class="l"> 5: </span>
<span class="l"> 6: </span>
<span class="l"> 7: </span>
<span class="l"> 8: </span>
<span class="l"> 9: </span>
<span class="l">10: </span>
<span class="l">11: </span>
<span class="l">12: </span>
<span class="l">13: </span>
<span class="l">14: </span>
<span class="l">15: </span>
<span class="l">16: </span>
<span class="l">17: </span>
<span class="l">18: </span>
<span class="l">19: </span>
</pre></td>
<td class="snippet"><pre class="fssnip highlighted"><code lang="fsharp"><span class="k">type</span> <span class="i">Person</span> <span class="o">=</span>
    {
        <span class="i">Address</span> <span class="o">:</span> <span class="i">string</span>
        <span class="i">Age</span> <span class="o">:</span> <span class="i">int</span>
        <span class="i">Name</span> <span class="o">:</span> <span class="i">string</span>
    }

<span class="k">let</span> <span class="i">makePerson</span> <span class="i">name</span> <span class="i">age</span> <span class="i">address</span> <span class="o">=</span>
    {
        <span class="i">Address</span> <span class="o">=</span> <span class="i">address</span>
        <span class="i">Age</span> <span class="o">=</span> <span class="i">age</span>
        <span class="i">Name</span> <span class="o">=</span> <span class="i">name</span>
    }

<span class="k">let</span> <span class="i">personPickler</span> <span class="o">=</span>
    <span class="i">Pickler</span><span class="o">.</span><span class="i">product</span> <span class="i">makePerson</span>
    <span class="o">^+</span> <span class="i">Pickler</span><span class="o">.</span><span class="i">field</span> (<span class="k">fun</span> <span class="i">p</span> <span class="k">-&gt;</span> <span class="i">p</span><span class="o">.</span><span class="i">Name</span>) <span class="i">Pickler</span><span class="o">.</span><span class="i">string</span>
    <span class="o">^+</span> <span class="i">Pickler</span><span class="o">.</span><span class="i">field</span> (<span class="k">fun</span> <span class="i">p</span> <span class="k">-&gt;</span> <span class="i">p</span><span class="o">.</span><span class="i">Age</span>) <span class="i">Pickler</span><span class="o">.</span><span class="i">int</span>
    <span class="o">^.</span> <span class="i">Pickler</span><span class="o">.</span><span class="i">field</span> (<span class="k">fun</span> <span class="i">p</span> <span class="k">-&gt;</span> <span class="i">p</span><span class="o">.</span><span class="i">Address</span>) <span class="i">Pickler</span><span class="o">.</span><span class="i">string</span>
</code></pre></td>
</tr>
</table>
<h4><a name="Unions-Sum-Types" class="anchor" href="#Unions-Sum-Types">Unions / Sum Types</a></h4>
<table class="pre"><tr><td class="lines"><pre class="fssnip"><span class="l"> 1: </span>
<span class="l"> 2: </span>
<span class="l"> 3: </span>
<span class="l"> 4: </span>
<span class="l"> 5: </span>
<span class="l"> 6: </span>
<span class="l"> 7: </span>
<span class="l"> 8: </span>
<span class="l"> 9: </span>
<span class="l">10: </span>
<span class="l">11: </span>
<span class="l">12: </span>
<span class="l">13: </span>
<span class="l">14: </span>
</pre></td>
<td class="snippet"><pre class="fssnip highlighted"><code lang="fsharp"><span class="k">type</span> <span class="i">U</span> <span class="o">=</span>
| <span class="i">Case1</span>
| <span class="i">Case2</span> <span class="k">of</span> <span class="i">int</span>
| <span class="i">Case3</span> <span class="k">of</span> <span class="i">string</span> <span class="o">*</span> <span class="i">int</span>

<span class="k">let</span> <span class="i">uPickler</span> <span class="o">=</span>
    <span class="i">Pickler</span><span class="o">.</span><span class="i">sum</span> (<span class="k">fun</span> <span class="i">x</span> <span class="i">k1</span> <span class="i">k2</span> <span class="i">k3</span> <span class="k">-&gt;</span>
        <span class="k">match</span> <span class="i">x</span> <span class="k">with</span>
        | <span class="i">Case1</span> <span class="k">-&gt;</span> <span class="i">k1</span> ()
        | <span class="i">Case2</span> <span class="i">x</span> <span class="k">-&gt;</span> <span class="i">k2</span> <span class="i">x</span>
        | <span class="i">Case3</span> (<span class="i">x</span>, <span class="i">y</span>) <span class="k">-&gt;</span> <span class="i">k3</span> (<span class="i">x</span>, <span class="i">y</span>))
    <span class="o">^+</span> <span class="i">Pickler</span><span class="o">.</span><span class="i">variant</span> <span class="i">Case1</span>
    <span class="o">^+</span> <span class="i">Pickler</span><span class="o">.</span><span class="i">case</span> <span class="i">Case2</span> <span class="i">Pickler</span><span class="o">.</span><span class="i">int</span>
    <span class="o">^.</span> <span class="i">Pickler</span><span class="o">.</span><span class="i">case</span> <span class="i">Case3</span> (<span class="i">Pickler</span><span class="o">.</span><span class="i">pair</span> <span class="i">Pickler</span><span class="o">.</span><span class="i">string</span> <span class="i">Pickler</span><span class="o">.</span><span class="i">int</span>)
</code></pre></td>
</tr>
</table>
<h2><a name="Generating-custom-picklers-in-type-definitions" class="anchor" href="#Generating-custom-picklers-in-type-definitions">Generating custom picklers in type definitions</a></h2>
<p>FsPickler can be instructed to use custom pickler definitions for given types
using the following design pattern:</p>
<table class="pre"><tr><td class="lines"><pre class="fssnip"><span class="l"> 1: </span>
<span class="l"> 2: </span>
<span class="l"> 3: </span>
<span class="l"> 4: </span>
<span class="l"> 5: </span>
<span class="l"> 6: </span>
<span class="l"> 7: </span>
<span class="l"> 8: </span>
<span class="l"> 9: </span>
<span class="l">10: </span>
<span class="l">11: </span>
<span class="l">12: </span>
<span class="l">13: </span>
<span class="l">14: </span>
<span class="l">15: </span>
<span class="l">16: </span>
<span class="l">17: </span>
<span class="l">18: </span>
<span class="l">19: </span>
<span class="l">20: </span>
</pre></td>
<td class="snippet"><pre class="fssnip highlighted"><code lang="fsharp">[&lt;<span class="i">CustomPickler</span>&gt;]
<span class="k">type</span> <span class="i">CustomClass</span><span class="o">&lt;</span><span class="o">&#39;</span><span class="i">T</span>, <span class="o">&#39;</span><span class="i">S</span><span class="o">&gt;</span> (<span class="i">x</span> <span class="o">:</span> <span class="o">&#39;</span><span class="i">T</span>, <span class="i">y</span> <span class="o">:</span> <span class="o">&#39;</span><span class="i">S</span>) <span class="o">=</span>

    <span class="k">member</span> <span class="i">__</span><span class="o">.</span><span class="i">X</span> <span class="o">=</span> <span class="i">x</span>
    <span class="k">member</span> <span class="i">__</span><span class="o">.</span><span class="i">Y</span> <span class="o">=</span> <span class="i">y</span>

    <span class="k">static</span> <span class="k">member</span> <span class="i">CreatePickler</span> (<span class="i">resolver</span> <span class="o">:</span> <span class="i">IPicklerResolver</span>) <span class="o">=</span>
        <span class="k">let</span> <span class="i">xp</span> <span class="o">=</span> <span class="i">resolver</span><span class="o">.</span><span class="i">Resolve</span><span class="o">&lt;</span><span class="o">&#39;</span><span class="i">T</span><span class="o">&gt;</span> ()
        <span class="k">let</span> <span class="i">yp</span> <span class="o">=</span> <span class="i">resolver</span><span class="o">.</span><span class="i">Resolve</span><span class="o">&lt;</span><span class="o">&#39;</span><span class="i">S</span><span class="o">&gt;</span> ()

        <span class="k">let</span> <span class="i">writer</span> (<span class="i">ws</span> <span class="o">:</span> <span class="i">WriteState</span>) (<span class="i">c</span> <span class="o">:</span> <span class="i">CustomClass</span><span class="o">&lt;</span><span class="o">&#39;</span><span class="i">T</span>,<span class="o">&#39;</span><span class="i">S</span><span class="o">&gt;</span>) <span class="o">=</span>
            <span class="i">xp</span><span class="o">.</span><span class="i">Write</span> <span class="i">ws</span> <span class="s">&quot;X&quot;</span> <span class="i">c</span><span class="o">.</span><span class="i">X</span>
            <span class="i">yp</span><span class="o">.</span><span class="i">Write</span> <span class="i">ws</span> <span class="s">&quot;Y&quot;</span> <span class="i">c</span><span class="o">.</span><span class="i">Y</span>

        <span class="k">let</span> <span class="i">reader</span> (<span class="i">rs</span> <span class="o">:</span> <span class="i">ReadState</span>) <span class="o">=</span>
            <span class="k">let</span> <span class="i">x</span> <span class="o">=</span> <span class="i">xp</span><span class="o">.</span><span class="i">Read</span> <span class="i">rs</span> <span class="s">&quot;X&quot;</span>
            <span class="k">let</span> <span class="i">y</span> <span class="o">=</span> <span class="i">yp</span><span class="o">.</span><span class="i">Read</span> <span class="i">rs</span> <span class="s">&quot;Y&quot;</span>
            <span class="k">new</span> <span class="i">CustomClass</span><span class="o">&lt;</span>_,_<span class="o">&gt;</span>(<span class="i">x</span>,<span class="i">y</span>)

        <span class="i">Pickler</span><span class="o">.</span><span class="i">FromPrimitives</span>(<span class="i">reader</span>, <span class="i">writer</span>)
</code></pre></td>
</tr>
</table>
<p>This tells FsPickler to generate a pickler for the given type using
that particular factory method. It should be noted that the <code>Read</code>/<code>Write</code>
operations are not commutative, hence care should be taken so that ordering is matched.
The <code>IPicklerResolver</code> argument provides a handle to the pickler generator and can be used recursively:</p>
<table class="pre"><tr><td class="lines"><pre class="fssnip"><span class="l"> 1: </span>
<span class="l"> 2: </span>
<span class="l"> 3: </span>
<span class="l"> 4: </span>
<span class="l"> 5: </span>
<span class="l"> 6: </span>
<span class="l"> 7: </span>
<span class="l"> 8: </span>
<span class="l"> 9: </span>
<span class="l">10: </span>
<span class="l">11: </span>
<span class="l">12: </span>
<span class="l">13: </span>
<span class="l">14: </span>
<span class="l">15: </span>
</pre></td>
<td class="snippet"><pre class="fssnip highlighted"><code lang="fsharp">[&lt;<span class="i">CustomPickler</span>&gt;]
<span class="k">type</span> <span class="i">RecursiveClass</span>(<span class="o">?</span><span class="i">nested</span> <span class="o">:</span> <span class="i">RecursiveClass</span>) <span class="o">=</span>

    <span class="k">member</span> <span class="i">__</span><span class="o">.</span><span class="i">Value</span> <span class="o">=</span> <span class="i">nested</span>

    <span class="k">static</span> <span class="k">member</span> <span class="i">CreatePickler</span> (<span class="i">resolver</span> <span class="o">:</span> <span class="i">IPicklerResolver</span>) <span class="o">=</span>
        <span class="k">let</span> <span class="i">self</span> <span class="o">=</span> <span class="i">resolver</span><span class="o">.</span><span class="i">Resolve</span><span class="o">&lt;</span><span class="i">RecursiveClass</span><span class="o">&gt;</span> ()
        <span class="i">self</span>
        <span class="o">|&gt;</span> <span class="i">Pickler</span><span class="o">.</span><span class="i">option</span> 
        <span class="o">|&gt;</span> <span class="i">Pickler</span><span class="o">.</span><span class="i">wrap</span> (<span class="k">fun</span> <span class="i">x</span> <span class="k">-&gt;</span> <span class="i">RecursiveClass</span>(<span class="o">?</span><span class="i">nested</span> <span class="o">=</span> <span class="i">x</span>)) (<span class="k">fun</span> <span class="i">rc</span> <span class="k">-&gt;</span> <span class="i">rc</span><span class="o">.</span><span class="i">Value</span>)

<span class="c">// a pickler will be generated based on the above definition</span>
<span class="k">let</span> <span class="i">p</span> <span class="o">=</span> <span class="i">FsPickler</span><span class="o">.</span><span class="i">GeneratePickler</span><span class="o">&lt;</span><span class="i">RecursiveClass</span><span class="o">&gt;</span> ()

<span class="i">RecursiveClass</span>(<span class="i">RecursiveClass</span>()) <span class="o">|&gt;</span> <span class="i">Json</span><span class="o">.</span><span class="i">pickle</span> <span class="i">p</span> <span class="o">|&gt;</span> <span class="i">Json</span><span class="o">.</span><span class="i">unpickle</span> <span class="i">p</span>
</code></pre></td>
</tr>
</table>
<h2><a name="Custom-pickler-registrations" class="anchor" href="#Custom-pickler-registrations">Custom pickler registrations</a></h2>
<p>Consider a type declaration that has not been made serializable:</p>
<table class="pre"><tr><td class="lines"><pre class="fssnip"><span class="l">1: </span>
<span class="l">2: </span>
<span class="l">3: </span>
</pre></td>
<td class="snippet"><pre class="fssnip highlighted"><code lang="fsharp">[&lt;<span class="i">AutoSerializable</span>(<span class="k">false</span>)&gt;]
<span class="k">type</span> <span class="i">NonSerializable</span>(<span class="i">value</span> <span class="o">:</span> <span class="i">int</span>) <span class="o">=</span>
    <span class="k">member</span> <span class="i">__</span><span class="o">.</span><span class="i">Value</span> <span class="o">=</span> <span class="i">value</span>
</code></pre></td>
</tr>
</table>
<p>Attempting to generate a pickler for the particular type</p>
<table class="pre"><tr><td class="lines"><pre class="fssnip"><span class="l">1: </span>
</pre></td>
<td class="snippet"><pre class="fssnip highlighted"><code lang="fsharp"><span class="i">FsPickler</span><span class="o">.</span><span class="i">GeneratePickler</span><span class="o">&lt;</span><span class="i">NonSerializable</span><span class="o">&gt;</span>()
</code></pre></td>
</tr>
</table>
<p>would result in an error:</p>
<table class="pre"><tr><td class="lines"><pre class="fssnip"><span class="l">1: </span>
<span class="l">2: </span>
<span class="l">3: </span>
<span class="l">4: </span>
</pre></td>
<td class="snippet"><pre class="fssnip"><code lang="text">MBrace.FsPickler.NonSerializableTypeException: Type 'FSI_0012+NonSerializable' is not serializable.
    at MBrace.FsPickler.Utils.Exn`1.get_Value() in C:\Users\eirik.tsarpalis\devel\mbrace\FsPickler\src\FsPickler\Utils\Utils.fs:line 59
    at MBrace.FsPickler.PicklerCache.MBrace-FsPickler-IPicklerResolver-Resolve[T]() in C:\Users\eirik.tsarpalis\devel\mbrace\FsPickler\src\FsPickler\PicklerGeneration\PicklerCache.fs:line 75
    at &lt;StartupCode$FSI_0013&gt;.$FSI_0013.main@()
</code></pre></td></tr></table>
<p>This problem can be overcome by creating a custom pickler cache that accepts user-supplied pickler registrations.
Suppose we have a custom pickler definition:</p>
<table class="pre"><tr><td class="lines"><pre class="fssnip"><span class="l"> 1: </span>
<span class="l"> 2: </span>
<span class="l"> 3: </span>
<span class="l"> 4: </span>
<span class="l"> 5: </span>
<span class="l"> 6: </span>
<span class="l"> 7: </span>
<span class="l"> 8: </span>
<span class="l"> 9: </span>
<span class="l">10: </span>
</pre></td>
<td class="snippet"><pre class="fssnip highlighted"><code lang="fsharp"><span class="k">let</span> <span class="i">mkPickler</span> (<span class="i">resolver</span> <span class="o">:</span> <span class="i">IPicklerResolver</span>) <span class="o">=</span>
    <span class="k">let</span> <span class="i">intPickler</span> <span class="o">=</span> <span class="i">resolver</span><span class="o">.</span><span class="i">Resolve</span><span class="o">&lt;</span><span class="i">int</span><span class="o">&gt;</span> ()

    <span class="k">let</span> <span class="i">writer</span> (<span class="i">w</span> <span class="o">:</span> <span class="i">WriteState</span>) (<span class="i">ns</span> <span class="o">:</span> <span class="i">NonSerializable</span>) <span class="o">=</span>
        <span class="i">intPickler</span><span class="o">.</span><span class="i">Write</span> <span class="i">w</span> <span class="s">&quot;value&quot;</span> <span class="i">ns</span><span class="o">.</span><span class="i">Value</span>

    <span class="k">let</span> <span class="i">reader</span> (<span class="i">r</span> <span class="o">:</span> <span class="i">ReadState</span>) <span class="o">=</span>
        <span class="k">let</span> <span class="i">v</span> <span class="o">=</span> <span class="i">intPickler</span><span class="o">.</span><span class="i">Read</span> <span class="i">r</span> <span class="s">&quot;value&quot;</span> <span class="k">in</span> <span class="i">NonSerializable</span>(<span class="i">v</span>)

    <span class="i">Pickler</span><span class="o">.</span><span class="i">FromPrimitives</span>(<span class="i">reader</span>, <span class="i">writer</span>)
</code></pre></td>
</tr>
</table>
<p>We can then create a custom pickler cache like so:</p>
<table class="pre"><tr><td class="lines"><pre class="fssnip"><span class="l"> 1: </span>
<span class="l"> 2: </span>
<span class="l"> 3: </span>
<span class="l"> 4: </span>
<span class="l"> 5: </span>
<span class="l"> 6: </span>
<span class="l"> 7: </span>
<span class="l"> 8: </span>
<span class="l"> 9: </span>
<span class="l">10: </span>
<span class="l">11: </span>
<span class="l">12: </span>
</pre></td>
<td class="snippet"><pre class="fssnip highlighted"><code lang="fsharp"><span class="c">// 1. Create a pickler registry and make custom pickler registrations</span>
<span class="k">let</span> <span class="i">registry</span> <span class="o">=</span> <span class="k">new</span> <span class="i">CustomPicklerRegistry</span>()
<span class="k">do</span> <span class="i">registry</span><span class="o">.</span><span class="i">RegisterFactory</span> <span class="i">mkPickler</span>

<span class="c">// 2. Construct a new pickler cache</span>
<span class="k">let</span> <span class="i">cache</span> <span class="o">=</span> <span class="i">PicklerCache</span><span class="o">.</span><span class="i">FromCustomPicklerRegistry</span> <span class="i">registry</span>

<span class="c">// 3. Pass the new cache to a serializer instance</span>
<span class="k">let</span> <span class="i">jsonSer</span> <span class="o">=</span> <span class="i">FsPickler</span><span class="o">.</span><span class="i">CreateJsonSerializer</span>(<span class="i">picklerResolver</span> <span class="o">=</span> <span class="i">cache</span>)

<span class="c">// 4. Serialize the custom type</span>
<span class="i">jsonSer</span><span class="o">.</span><span class="i">PickleToString</span> (<span class="i">NonSerializable</span> <span class="n">42</span>)
</code></pre></td>
</tr>
</table>
<p>In some cases, it might be sufficient to declare that FsPickler should treat
the type as if it wasn't lacking a <code>[&lt;Serializable&gt;]</code> annotation:</p>
<table class="pre"><tr><td class="lines"><pre class="fssnip"><span class="l">1: </span>
</pre></td>
<td class="snippet"><pre class="fssnip highlighted"><code lang="fsharp"><span class="i">registry</span><span class="o">.</span><span class="i">DeclareSerializable</span><span class="o">&lt;</span><span class="i">NonSerializable</span><span class="o">&gt;</span>()
</code></pre></td>
</tr>
</table>
<h2><a name="Additional-tools" class="anchor" href="#Additional-tools">Additional tools</a></h2>
<p>This section describes some of the additional tools offered by the library:</p>
<h3><a name="Object-Cloning" class="anchor" href="#Object-Cloning">Object Cloning</a></h3>
<p>FsPickler 1.2 adds support for fast cloning of serializable objects.
This is done in a node-per-node basis, without the need for serialization formats and intermediate buffers.</p>
<table class="pre"><tr><td class="lines"><pre class="fssnip"><span class="l">1: </span>
</pre></td>
<td class="snippet"><pre class="fssnip highlighted"><code lang="fsharp"><span class="k">let</span> <span class="i">clonedValue</span> <span class="o">=</span> <span class="i">FsPickler</span><span class="o">.</span><span class="i">Clone</span> [<span class="i">Choice1Of2</span> <span class="s">&quot;foo&quot;</span> ; <span class="i">Choice2Of2</span> [<span class="s">&#39;b&#39;</span>;<span class="s">&#39;a&#39;</span>;<span class="s">&#39;r&#39;</span>]]
</code></pre></td>
</tr>
</table>
<h3><a name="Structural-Hashcodes" class="anchor" href="#Structural-Hashcodes">Structural Hashcodes</a></h3>
<p>FsPickler offers experimental support for structural, non-cryptographic, hashcode generation:</p>
<table class="pre"><tr><td class="lines"><pre class="fssnip"><span class="l">1: </span>
<span class="l">2: </span>
<span class="l">3: </span>
<span class="l">4: </span>
<span class="l">5: </span>
<span class="l">6: </span>
<span class="l">7: </span>
<span class="l">8: </span>
</pre></td>
<td class="snippet"><pre class="fssnip highlighted"><code lang="fsharp"><span class="k">let</span> <span class="i">hash</span> <span class="o">=</span> <span class="i">FsPickler</span><span class="o">.</span><span class="i">ComputeHash</span> [<span class="n">1</span> <span class="o">..</span> <span class="n">100000</span>]

<span class="c">//val it : HashResult =</span>
<span class="c">//  {Algorithm = &quot;MurMur3&quot;;</span>
<span class="c">//   Length = 400008L;</span>
<span class="c">//   Hash =</span>
<span class="c">//    [|52uy; 70uy; 141uy; 214uy; 3uy; 231uy; 11uy; 100uy; 94uy; 250uy; 231uy;</span>
<span class="c">//      97uy; 188uy; 215uy; 70uy; 0uy|];}</span>
</code></pre></td>
</tr>
</table>
<p>This will generate a 128-bit structural hashcode based on the <a href="http://en.wikipedia.org/wiki/MurmurHash">MurMurHash</a> algorithm.
Implementation is memory efficient, since the hashing algorithm is integrated with
the underlying stream implementation. It is possible for users to define their own hashing
algorithms by inheriting the special <code>HashStream</code> class.</p>
<p>Hashing functionality offered by FsPickler is an ideal replacement to <code>.GetHashCode()</code> for
large objects or complex object graphs, but it is not recommended for small values or primitives.</p>
<p>If a hashcode is not required, the size of an object alone can be computed as follows:</p>
<table class="pre"><tr><td class="lines"><pre class="fssnip"><span class="l">1: </span>
<span class="l">2: </span>
<span class="l">3: </span>
</pre></td>
<td class="snippet"><pre class="fssnip highlighted"><code lang="fsharp"><span class="i">FsPickler</span><span class="o">.</span><span class="i">ComputeSize</span> [<span class="n">1</span> <span class="o">..</span> <span class="n">1000000</span>]

<span class="c">//val it : int64 = 4000008L</span>
</code></pre></td>
</tr>
</table>
<h3><a name="Typed-Serialization" class="anchor" href="#Typed-Serialization">Typed Serialization</a></h3>
<p>It is possible to create typed picklings of objects:</p>
<table class="pre"><tr><td class="lines"><pre class="fssnip"><span class="l">1: </span>
</pre></td>
<td class="snippet"><pre class="fssnip highlighted"><code lang="fsharp"><span class="k">let</span> <span class="i">typedPickle</span> <span class="o">=</span> <span class="i">jsonSerializer</span><span class="o">.</span><span class="i">PickleTyped</span> [<span class="n">1</span> <span class="o">..</span> <span class="n">1000</span>]
</code></pre></td>
</tr>
</table>
<p>this will produce a serialization annotated with the type of the original object.
They can then be easily deserialized like so:</p>
<table class="pre"><tr><td class="lines"><pre class="fssnip"><span class="l">1: </span>
</pre></td>
<td class="snippet"><pre class="fssnip highlighted"><code lang="fsharp"><span class="k">let</span> <span class="i">value</span> <span class="o">=</span> <span class="i">jsonSerializer</span><span class="o">.</span><span class="i">UnPickleTyped</span> <span class="i">typedPickle</span>
</code></pre></td>
</tr>
</table>
<h3><a name="Object-Sifting" class="anchor" href="#Object-Sifting">Object Sifting</a></h3>
<p>FsPickler 1.2 comes with a 'sifting' functionality which allows serialization/cloning while omitting specified
instances from an object graph. For example, consider the object graph</p>
<table class="pre"><tr><td class="lines"><pre class="fssnip"><span class="l">1: </span>
<span class="l">2: </span>
<span class="l">3: </span>
</pre></td>
<td class="snippet"><pre class="fssnip highlighted"><code lang="fsharp"><span class="k">let</span> <span class="i">small</span> <span class="o">=</span> [|<span class="n">1..</span><span class="n">10</span>|]
<span class="k">let</span> <span class="i">large</span> <span class="o">=</span> [|<span class="n">1..</span><span class="n">100000000</span>|]
<span class="k">let</span> <span class="i">graph</span> <span class="o">=</span> <span class="i">Some</span> [<span class="i">small</span>; <span class="i">large</span>; <span class="i">small</span>; <span class="i">large</span>]
</code></pre></td>
</tr>
</table>
<p>The size of the object becomes evident when running</p>
<table class="pre"><tr><td class="lines"><pre class="fssnip"><span class="l">1: </span>
<span class="l">2: </span>
<span class="l">3: </span>
</pre></td>
<td class="snippet"><pre class="fssnip highlighted"><code lang="fsharp"><span class="i">FsPickler</span><span class="o">.</span><span class="i">ComputeSize</span> <span class="i">graph</span>

<span class="c">//val it : int64 = 400000203L</span>
</code></pre></td>
</tr>
</table>
<p>Supposing we knew that the size of the graph was being bloated by large arrays,
we can use FsPickler to optimize serialization by sifting away occurences from the object graph.</p>
<table class="pre"><tr><td class="lines"><pre class="fssnip"><span class="l"> 1: </span>
<span class="l"> 2: </span>
<span class="l"> 3: </span>
<span class="l"> 4: </span>
<span class="l"> 5: </span>
<span class="l"> 6: </span>
<span class="l"> 7: </span>
<span class="l"> 8: </span>
<span class="l"> 9: </span>
<span class="l">10: </span>
<span class="l">11: </span>
<span class="l">12: </span>
<span class="l">13: </span>
<span class="l">14: </span>
<span class="l">15: </span>
<span class="l">16: </span>
</pre></td>
<td class="snippet"><pre class="fssnip highlighted"><code lang="fsharp"><span class="k">let</span> <span class="i">sifter</span> <span class="o">:</span> <span class="i">obj</span> <span class="k">-&gt;</span> <span class="i">bool</span> <span class="o">=</span> <span class="k">function</span> <span class="o">:?</span> (<span class="i">int</span> []) <span class="k">as</span> <span class="i">ts</span> <span class="k">-&gt;</span> <span class="i">ts</span><span class="o">.</span><span class="i">Length</span> <span class="o">&gt;</span> <span class="n">100</span> | _ <span class="k">-&gt;</span> <span class="k">false</span>
<span class="k">let</span> <span class="i">siftedGraph</span>, <span class="i">siftedValues</span> <span class="o">=</span> <span class="i">FsPickler</span><span class="o">.</span><span class="i">Sift</span>(<span class="i">graph</span>, <span class="i">sifter</span>)

<span class="c">//val siftedValues : (int64 * obj) [] =</span>
<span class="c">//  [|(4L,</span>
<span class="c">//     [|1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18; 19; 20;</span>
<span class="c">//       21; 22; 23; 24; 25; 26; 27; 28; 29; 30; 31; 32; 33; 34; 35; 36; 37; 38;</span>
<span class="c">//       39; 40; 41; 42; 43; 44; 45; 46; 47; 48; 49; 50; 51; 52; 53; 54; 55; 56;</span>
<span class="c">//       57; 58; 59; 60; 61; 62; 63; 64; 65; 66; 67; 68; 69; 70; 71; 72; 73; 74;</span>
<span class="c">//       75; 76; 77; 78; 79; 80; 81; 82; 83; 84; 85; 86; 87; 88; 89; 90; 91; 92;</span>
<span class="c">//       93; 94; 95; 96; 97; 98; 99; 100; ...|])|]</span>
<span class="c">//</span>
<span class="c">//val siftedGraph : Sifted&lt;int [] list option&gt; =</span>
<span class="c">//  Sift: Some</span>
<span class="c">//  [[|1; 2; 3; 4; 5; 6; 7; 8; 9; 10|]; null; [|1; 2; 3; 4; 5; 6; 7; 8; 9; 10|];</span>
<span class="c">//   null]</span>
</code></pre></td>
</tr>
</table>
<p>This will return a sifted clone of the original object as well as a collection of all objects that were sifted
from the original input. The sifted copy encapsulated in a wrapper type so that it cannot be consumed while in its partial state.
The original input graph will not be mutated in any way. We can verify that the size of the sifted object has been reduced:</p>
<table class="pre"><tr><td class="lines"><pre class="fssnip"><span class="l">1: </span>
<span class="l">2: </span>
<span class="l">3: </span>
</pre></td>
<td class="snippet"><pre class="fssnip highlighted"><code lang="fsharp"><span class="i">FsPickler</span><span class="o">.</span><span class="i">ComputeSize</span> <span class="i">siftedGraph</span>

<span class="c">//val it : int64 = 270L</span>
</code></pre></td>
</tr>
</table>
<p>Sifted objects can be put back together by calling</p>
<table class="pre"><tr><td class="lines"><pre class="fssnip"><span class="l">1: </span>
</pre></td>
<td class="snippet"><pre class="fssnip highlighted"><code lang="fsharp"><span class="k">let</span> <span class="i">reconstructed</span> <span class="o">=</span> <span class="i">FsPickler</span><span class="o">.</span><span class="i">UnSift</span>(<span class="i">siftedGraph</span>, <span class="i">siftedValues</span>)
</code></pre></td>
</tr>
</table>
<h3><a name="Object-Graph-Visitors" class="anchor" href="#Object-Graph-Visitors">Object Graph Visitors</a></h3>
<p>FsPickler is capable of efficiently traversing arbitrary object graphs (as long as they are serializable)
by exploiting its pickler infrastructure. This can be done by calling the method:</p>
<table class="pre"><tr><td class="lines"><pre class="fssnip"><span class="l">1: </span>
</pre></td>
<td class="snippet"><pre class="fssnip highlighted"><code lang="fsharp"><span class="i">FsPickler</span><span class="o">.</span><span class="i">VisitObject</span>
</code></pre></td>
</tr>
</table>
<p>which takes as input a serializable object graph and a so-called object visitor:</p>
<table class="pre"><tr><td class="lines"><pre class="fssnip"><span class="l">1: </span>
<span class="l">2: </span>
<span class="l">3: </span>
<span class="l">4: </span>
</pre></td>
<td class="snippet"><pre class="fssnip highlighted"><code lang="fsharp"><span class="k">type</span> <span class="i">IObjectVisitor</span> <span class="o">=</span>
  <span class="k">interface</span>
    <span class="k">abstract</span> <span class="k">member</span> <span class="i">Visit</span> <span class="o">:</span> <span class="i">Pickler</span><span class="o">&lt;</span><span class="o">&#39;</span><span class="i">T</span><span class="o">&gt;</span> <span class="o">*</span> <span class="o">&#39;</span><span class="i">T</span> <span class="k">-&gt;</span> <span class="i">bool</span>
  <span class="k">end</span>
</code></pre></td>
</tr>
</table>
<p>A few applications of this are provided by the core library:</p>
<table class="pre"><tr><td class="lines"><pre class="fssnip"><span class="l">1: </span>
<span class="l">2: </span>
<span class="l">3: </span>
<span class="l">4: </span>
<span class="l">5: </span>
<span class="l">6: </span>
</pre></td>
<td class="snippet"><pre class="fssnip highlighted"><code lang="fsharp"><span class="k">let</span> <span class="i">types</span> <span class="o">=</span> <span class="i">FsPickler</span><span class="o">.</span><span class="i">GatherTypesInObjectGraph</span> [<span class="i">box</span> <span class="n">42</span> ; <span class="i">box</span> (<span class="i">Some</span> (<span class="n">42</span>, <span class="s">&quot;42&quot;</span>))]

<span class="c">//val types : Type [] =</span>
<span class="c">//  [|Microsoft.FSharp.Collections.FSharpList`1[System.Object]; System.Int32;</span>
<span class="c">//    Microsoft.FSharp.Core.FSharpOption`1[System.Tuple`2[System.Int32,System.String]];</span>
<span class="c">//    System.Tuple`2[System.Int32,System.String]; System.String|]</span>
</code></pre></td>
</tr>
</table>
<h3><a name="Disabling-Subtype-Resolution" class="anchor" href="#Disabling-Subtype-Resolution">Disabling Subtype Resolution</a></h3>
<p>For security reasons, it might often be desirable to disable subtype resolution
when serializing classes:</p>
<table class="pre"><tr><td class="lines"><pre class="fssnip"><span class="l">1: </span>
</pre></td>
<td class="snippet"><pre class="fssnip highlighted"><code lang="fsharp"><span class="i">serializer</span><span class="o">.</span><span class="i">DisableSubtypeResolution</span> <span class="o">&lt;-</span> <span class="k">true</span>
</code></pre></td>
</tr>
</table>
<p>This essentially disables the serialization of any object whose declaring type
is specified on the serialization itself. Attempting to serialize or deserialize
any such object will result in an exception.</p>
<p>Note that enabling this option prevents serialization of the following types:</p>
<ul>
<li><code>System.Object</code> or any abstract class (excluding F# DUs).</li>
<li>Any delegate instance or F# function.</li>
<li>Any <code>ISerializable</code> class.</li>
</ul>
<p>As a further precaution, it is also possible to disable implicit assembly loading
when deserializing objects:</p>
<table class="pre"><tr><td class="lines"><pre class="fssnip"><span class="l">1: </span>
</pre></td>
<td class="snippet"><pre class="fssnip highlighted"><code lang="fsharp"><span class="i">serializer</span><span class="o">.</span><span class="i">DisableAssemblyLoading</span> <span class="o">&lt;-</span> <span class="k">true</span>
</code></pre></td>
</tr>
</table>
<h2><a name="Defining-Custom-Pickle-Formats" class="anchor" href="#Defining-Custom-Pickle-Formats">Defining Custom Pickle Formats</a></h2>
<p>It is possible to create user-defined pickle formats for FsPickler. One simply needs to implement the interface</p>
<table class="pre"><tr><td class="lines"><pre class="fssnip"><span class="l">1: </span>
<span class="l">2: </span>
<span class="l">3: </span>
<span class="l">4: </span>
<span class="l">5: </span>
<span class="l">6: </span>
<span class="l">7: </span>
</pre></td>
<td class="snippet"><pre class="fssnip highlighted"><code lang="fsharp"><span class="k">type</span> <span class="i">IPickleFormatProvider</span> <span class="o">=</span>
  <span class="k">interface</span>
    <span class="k">abstract</span> <span class="k">member</span> <span class="i">Name</span> <span class="o">:</span> <span class="i">string</span>
    <span class="k">abstract</span> <span class="i">DefaultEncoding</span> <span class="o">:</span> <span class="i">Encoding</span>
    <span class="k">abstract</span> <span class="k">member</span> <span class="i">CreateReader</span> <span class="o">:</span> <span class="i">Stream</span> <span class="o">*</span> <span class="i">Encoding</span> <span class="o">*</span> <span class="i">leaveOpen</span><span class="o">:</span><span class="i">bool</span> <span class="k">-&gt;</span> <span class="i">IPickleFormatReader</span>
    <span class="k">abstract</span> <span class="k">member</span> <span class="i">CreateWriter</span> <span class="o">:</span> <span class="i">Stream</span> <span class="o">*</span> <span class="i">Encoding</span> <span class="o">*</span> <span class="i">leaveOpen</span><span class="o">:</span><span class="i">bool</span> <span class="k">-&gt;</span> <span class="i">IPickleFormatWriter</span>
  <span class="k">end</span>
</code></pre></td>
</tr>
</table>
<p>which can then be bolted on a class that inherits either of the
<a href="reference/mbrace-fspickler-fspicklerserializer.html"><code>FsPicklerSerializer</code></a> or
<a href="reference/mbrace-fspickler-fspicklertextserializer.html"><code>FsPicklerTextSerializer</code></a>.</p>


        </div>
        <div class="span3">
          <a target="_blank" href="http://mbrace.io/">
      <img src="/FsPickler/img/mbrace.png" alt="F# Project" style="width:150px;margin:10px" /> 
      </a>
          <ul class="nav nav-list" id="menu" style="margin-top: 20px;">
            <li class="nav-header">FsPickler</li>
            <li><a href="/FsPickler/index.html">Home page</a></li>
            <li class="divider"></li>
            <li><a href="http://www.nuget.org/packages/FsPickler">Get Library via NuGet</a></li>
            <li><a href="http://github.com/mbraceproject/FsPickler">Source Code on GitHub</a></li>
            <li><a href="http://github.com/mbraceproject/FsPickler/blob/master/License.md">License</a></li>
            <li><a href="http://github.com/mbraceproject/FsPickler/blob/master/RELEASE_NOTES.md">Release Notes</a></li>

            <li class="nav-header">Documentation</li>
            <li><a href="/FsPickler/tutorial.html">Tutorial</a></li>
            <li><a href="/FsPickler/overview.html">Technical Overview</a></li>
            <li><a href="/FsPickler/benchmarks.html">Performance</a></li>
            <li><a href="/FsPickler/reference/index.html">API Reference</a></li>
          </ul>
        </div>
      </div>
    </div>
    <a href="http://github.com/mbraceproject/FsPickler"><img style="position: absolute; top: 0; right: 0; border: 0;" src="https://s3.amazonaws.com/github/ribbons/forkme_right_gray_6d6d6d.png" alt="Fork me on GitHub"/></a>
  </body>
  </html>
